#include "rpi-base.h"
#include "defs.h"

#include "macros.S"

#define FIELD_TYPE_THRESHOLD 32768

.text
.global rgb_to_fb
.global measure_vsync
.global measure_n_lines
.global sw1counter
.global sw2counter
.global sw3counter
.global vsync_line
.global default_vsync_line
.global lock_fail
.global customPalette
.global paletteHighNibble
.global dummyscreen
.global hsync_width
.global sync_state
.global offset_delay



.global analyse_sync

.global capture_line_mode7_4bpp_table
.global capture_line_normal_4bpp_table
.global capture_line_odd_4bpp_table
.global capture_line_even_4bpp_table
.global capture_line_double_4bpp_table
.global capture_line_half_odd_4bpp_table
.global capture_line_half_even_4bpp_table
.global capture_line_normal_8bpp_table
.global capture_line_odd_8bpp_table
.global capture_line_even_8bpp_table
.global capture_line_double_8bpp_table
.global capture_line_half_odd_8bpp_table
.global capture_line_half_even_8bpp_table
.global capture_line_atom_4bpp_table
.global capture_line_atom_8bpp_table


rgb_to_fb:

        push   {r4-r12, lr}

        // Save the capture_info_t parameters to absolute addresses
        ldr    r2, [r0, #O_FB_PITCH]
        str    r2, param_fb_pitch
        ldr    r2, [r0, #O_FB_WIDTH]
        str    r2, param_fb_width
        ldr    r2, [r0, #O_FB_HEIGHT]
        str    r2, param_fb_height
        ldr    r2, [r0, #O_FB_HEIGHTX2]
        str    r2, param_fb_heightx2
        ldr    r2, [r0, #O_FB_BPP]
        str    r2, param_fb_bpp
        ldr    r2, [r0, #O_CHARS_PER_LINE]
        str    r2, param_chars_per_line
        ldr    r2, [r0, #O_NLINES]
        str    r2, param_nlines
        ldr    r2, [r0, #O_H_OFFSET]
        ldr    r3, offset_delay
        subs   r2, r2, r3
        movmi  r2, #0
        str    r2, param_h_offset
        ldr    r2, [r0, #O_V_OFFSET]
        str    r2, param_v_offset
        ldr    r2, [r0, #O_NCAPTURE]
        str    r2, param_ncapture
        ldr    r2, [r0, #O_CAPTURE_LINE]
        str    r2, param_capture_line
        ldr    r2, [r0, #O_PALETTE_CONTROL]
        str    r2, param_palette_control
        ldr    r2, [r0, #O_SAMPLE_WIDTH]
        str    r2, param_sample_width
        ldr    r2, [r0, #O_FB_BASE]
        str    r2, param_framebuffer0
        // Sanity check chars_per_line <= fb_width / 8
        ldr    r3, param_fb_width
        lsr    r3, r3, #3
        ldr    r2, param_chars_per_line
        cmp    r2, r3
        strgt  r3, param_chars_per_line

        // Sanity check nlines <= fb_height
        ldr    r3, param_fb_height
        ldr    r2, param_nlines
        cmp    r2, r3
        strgt  r3, param_nlines

#ifdef MULTI_BUFFER
        // Calculate the base address of each of the 4 frame buffers
        ldr    r10, param_fb_height
        ldr    r11, param_fb_pitch
        ldr    r2, param_framebuffer0
        mul    r10, r10, r11
        add    r2, r10
        str    r2, param_framebuffer1
        add    r2, r10
        str    r2, param_framebuffer2
        add    r2, r10
        str    r2, param_framebuffer3
        // Default to displaying buffer 0 in Mode 7 (or on probe)
        tst    r1, #(BIT_MODE7 | BIT_PROBE) // options currently in r1!
        beq    skip_swap
        push   {r0-r3}
        mov    r0, #0
        bl     swapBuffer
        pop    {r0-r3}
skip_swap:
#endif
        // Setup r4 as a constant
        ldr    r4, =GPLEV0

        // Setup r3 with the flags/options parameter (as per before)
        mov    r3, r1

        // Setup r2 with the framebuffer pitch (as per before)
        ldr    r2, param_fb_pitch

        // Setup r2 with the number of active characters per line (as per before)
        ldr    r1, param_chars_per_line

        tst    r3, #BIT_CLEAR
        blne   clear_screen

        // Clear the following state bits:
        bic    r3, r3, #(BIT_FIELD_TYPE | BIT_CLEAR)
        bic    r3, r3, #(BIT_FIELD_TYPE1_VALID)

        // In Mode 7 (or on probe) write to buffer 0, display buffer 0
        bic    r3, r3, #(MASK_LAST_BUFFER | MASK_CURR_BUFFER)
#ifdef MULTI_BUFFER
        tst    r3, #(BIT_MODE7 | BIT_PROBE)
        // In modes 0..6, restore the previous buffer state
        ldreq  r10, buffer_state
        orreq  r3, r3, r10
#endif

        ldr    r8, param_h_offset
        ldr    r9, param_sample_width
        ands   r9, r9, #1
        movne  r8, r8, lsl #1
        addne  r8, r8, #1
        str    r8, param_h_offset

        // If the sample width is 0 (3 bits) do the second PSYNC read
        // (maintains backwards compatibility with CPLDv1 and CPLDv2)
        orreq  r3, r3, #BIT_PSYNC_DOUBLE_READ

        ldr    r8, sync_state
        tst    r8, #SYNC_BIT_SEPARATE_SYNC 
        orrne  r3, r3, #BIT_SEPARATE_SYNC 
        tst    r8, #SYNC_BIT_VSYNC_INVERTED 
        orrne  r3, r3, #BIT_VSYNC_INVERTED
        
        ldr    r8, param_palette_control
        cmp    r8, #2
        movgt  r8, #2
        mov    r8, r8, lsl #1
        orr    r8, r8, r9
        ldr    r9, param_capture_line
        add    r9, r9, r8, lsl #2
        ldr    r8, [r9]
        str    r8, capture_address

        ldr    r8, =sentinel
        ldr    r9, =0x48444d49         // "HDMI" sentinel
        str    r9, [r8]

        ldr    r7, param_fb_heightx2
        cmp    r7, #0
        bicne  r3, r3, #BIT_NO_LINE_DOUBLE
        orreq  r3, r3, #BIT_NO_LINE_DOUBLE
frame:

        bl     wait_for_vsync
        ldr    r0, default_vsync_line
        str    r0, vsync_line          // default for vsync line if vsync in blanking area

        ldr    r8, =inBandPointer
        ldr    r9, =inBandData
        str    r9, [r8]

        ldr    r8, =paletteFlags
        ldr    r9, [r8]
        bic    r9, r9, #BIT_IN_BAND_DETECTED     //in band data detected
        str    r9, [r8]


        // Working registers while frame is being captured
        //
        //  r0 = scratch register
        //  r1 = number of 8-pixel blocks to capture (=param_chars_per_line)
        //  r2 = frame buffer line pitch in bytes (=param_fb_pitch)
        //  r3 = flags register
        //  r4 = GPLEV0 constant
        //  r5 = line counter (counts down to 0)
        //  r6 = scratch register
        //  r7 = scratch register
        //  r8 = value read from GPLEV0
        //  r9 = scratch register
        // r10 = scratch register
        // r11 = pointer to current line in frame buffer

        // Pick the next draw buffer
        // In Mode 7, or if MULTI_BUFFER disabled, than draw to 0
        // else draw to the "spare" buffer
        mov    r0, #0
#ifdef MULTI_BUFFER
        tst    r3, #(BIT_MODE7 | BIT_PROBE)
        bne    buffer_chosen
        // Draw to the buffers cyclically, i.e. pick the one
        // after the last completed buffer, modulo <nbuffers + 1>
        // r8 and r9 are free at this point
        mov    r8, r3, lsr #OFFSET_LAST_BUFFER
        and    r8, r8, #3
        mov    r9, r3, lsr #OFFSET_NBUFFERS
        and    r9, r9, #3
        cmp    r8, r9
        beq    buffer_chosen
        add    r0, r8, #1
buffer_chosen:
#endif
        ldr    r8, =param_framebuffer0
        ldr    r11, [r8, r0, lsl #2]

        // remember this as the current buffer
        bic    r3, r3, #MASK_CURR_BUFFER
        orr    r3, r3, r0, lsl #OFFSET_CURR_BUFFER

        // The odd vs even field can be distinguished by the time between
        // the last two rising edges:
        // odd field (first field) should be 21/23us
        // even field (second field) should be 53/55us
        sub    r6, r6, r7

        // Save the current field type
        cmp    r6, #FIELD_TYPE_THRESHOLD
        biclt  r3, r3, #BIT_FIELD_TYPE  // Odd, clear bit
        orrge  r3, r3, #BIT_FIELD_TYPE  // Even, set bit

        // Check for mode change:
        // Odd: Mode 0..6 should be 21us, Mode 7 should be 23us
        // Even: Mode 0..6 should be 53us, Mode 7 should be 55us
        //
        // The above changes with smooth horizontal scrolling
        // - with R3= 6: 20.0us/52.0us
        // - with R3= 7: 20.5us/52.5us
        // - with R3= 8: 21.0us/53.0us <<< "Normal" case
        // - with R3= 9: 21.5us/53.5us
        // - with R3=10: 22.0us/54.0us
        //
        // Hence we use thresholds of 22.5us and 54.5us
        tst    r3, #BIT_FIELD_TYPE
        ldreq  r5, =22500     // Use 22.5us threshold in odd field
        ldrne  r5, =54500     // Use 54.5us threshold in even field
        cmp    r6, r5
        movlt  r0, #0         // Modes 0-6
        movge  r0, #1         // Mode 7
        tst    r3, #BIT_PROBE
        bne    exit
        tst    r3, #BIT_CALIBRATE
        bne    skip_switch_test

        // Test for keys being pressed, with variable rate auto repeat
        // Note: macro uses r5 as a scratch register
        ldr    r8, [r4]
        KEY_PRESS_DETECT SW1_MASK, RET_SW1, sw1counter
        KEY_PRESS_DETECT SW2_MASK, RET_SW2, sw2counter
        KEY_PRESS_DETECT SW3_MASK, RET_SW3, sw3counter
        tst    r0, #(RET_SW1 | RET_SW2 | RET_SW3)
        bne    exit

skip_switch_test:
        tst    r3, #BIT_MODE_DETECT // Have we been told to exit on mode change
        beq    skip_mode_test

        tst    r3, #BIT_MODE7
        moveq  r5, #0         // Modes 0-6
        movne  r5, #1         // Mode 7
        cmp    r5, r0         // Check if we have changed mode
        bne    exit           // If so, then bail, as the frame buffer needs to be resized

        tst    r3, #BIT_FIELD_TYPE1_VALID
        beq    skip_interlace_test // we haven't yet seen two fields, so skip the test

        // XOR BIT_FIELD_TYPE and BIT_FIELD_TYPE1 to determine if the current frame is interlacd
        // FT1 FT
        // 0   0 -> 0
        // 0   1 -> 1
        // 1   0 -> 1
        // 1   1 -> 0
        // then XOR BIT_INTERLACED and if the result is 1 then the interlace mode has changed
        tst    r3, #BIT_FIELD_TYPE
        eorne  r3, #BIT_FIELD_TYPE1
        tst    r3, #BIT_INTERLACED
        eorne  r3, #BIT_FIELD_TYPE1
        tst    r3, #BIT_FIELD_TYPE1
        orrne  r0, #RET_INTERLACE_CHANGED
        bne    exit

skip_interlace_test:

        // copy BIT_FIELD_TYPE to BIT_FIELD_TYPE1
        tst    r3, #BIT_FIELD_TYPE
        biceq  r3, #BIT_FIELD_TYPE1
        orrne  r3, #BIT_FIELD_TYPE1
        orr    r3, #BIT_FIELD_TYPE1_VALID   // set the valid bit

skip_mode_test:

        // Save a copy of the frame buffer base
        push   {r11}

        // Skip inactive lines
        ldr    r5, param_v_offset

        // Correct the relative positions of the odd and even frames
        // In Mode 0..6, reduce the number of active lines by one for the even frame
        // In Mode 7, increment the frame buffer pointer by one line for the even field
        tst    r3, #BIT_ELK
        bne    skip_line_loop
        tst    r3, #BIT_MODE7
        beq    fixupmodes
        tst    r3, #BIT_FIELD_TYPE
        addeq  r11, r11, r2
fixupmodes:
        tst    r3, #BIT_FIELD_TYPE
        subne  r5, r5, #1     // Modes 0-6 + 7
skip_line_loop:
        cmp    r5, #0
        ble    skip_line_loop_exit
        WAIT_FOR_CSYNC_0
        WAIT_FOR_CSYNC_1
        subs   r5, r5, #1
        b      skip_line_loop
skip_line_loop_exit:

        push   {r1-r5, r11}

        ldr    r12, capture_address
        sub    r12, r12, #4
        // Call preload capture line function (runs all paths of capture code to preload it into cache)
        blx    r12
        pop    {r1-r5, r11}

        // Compute the current scanline mod 10
        ldr    r5, param_v_offset
        CLEAR_VSYNC
        add    r5, r5, #2
mod10:
        subs   r5, r5, #10
        bpl    mod10
        add    r5, r5, #10
        str    r5, linecountmod10

        // Process active lines
        ldr    r5, param_nlines
process_line_loop:

        SHOW_VSYNC

        // Preserve the state used by the outer code
        push   {r1-r5, r11}

        ldr     r5, param_fb_height
        adrl    r0, paletteHighNibble
        ldr     r6, param_nlines
        sub     r6, r6, r5
        subs    r6, r6, #VERTICAL_OFFSET
        movmi   r6, #0
        cmp     r6, #0x100
        movge   r6, #0xff
        ldrb    r8, [r0, r6]

        ldr     r6, =paletteFlags
        ldr     r9, [r6]
        bic     r9, r9, #0xf0000000
        tst     r9, #BIT_MULTI_PALETTE
        orrne   r9, r9, r8, lsl#28
        str     r9, [r6]

        // The capture line function is provided the following:
        //   r0 = pointer to current line in frame buffer
        //   r1 = number of complete psync cycles to capture (=param_chars_per_line)
        //   r2 = frame buffer line pitch in bytes (=param_fb_pitch)
        //   r3 = flags register
        //   r4 = GPLEV0 constant
        //   r5 = frame buffer height (=param_fb_height)
        //   r6 = scan line count modulo 10
        //   r7 = number of psyncs to skip
        //
        // All registers are available as scratch registers (i.e. nothing needs to be preserved)

        // Setup parameters
        mov    r0, r11
        ldr    r6, linecountmod10
        ldr    r7, param_h_offset
        // Load the address of the capture_line function into r12
        ldr    r12, capture_address
        // Call capture line function
        blx    r12

        // Restore the state used by the outer code

        pop    {r1-r5, r11}

        ldr    r7, param_fb_heightx2
        cmp    r7, #0
        // Skip a whole line to maintain aspect ratio
        ldr    r0, linecountmod10
        addne  r11, r11, r2, lsl #1
        addeq  r11, r11, r2
        add    r0, r0, #1
        cmp    r0, #10
        moveq  r0, #0
        str    r0, linecountmod10

        subs   r5, r5, #1
        bne    process_line_loop

        push   {r1-r5, r11}

        ldr    r9, =paletteFlags
        ldr    r8, [r9]
        bic    r8, r8, #BIT_SET_MODE2_16COLOUR   // mode 2 emulation flag
        bic    r8, r8, #BIT_MODE2_PALETTE
        mov    r9, #0           // palette changed flag



        tst    r8, #BIT_IN_BAND_DETECTED
        beq    noInBandData

        adrl    r10, customPalette
        ldr    r12, =inBandData
        ldrb   r11, [r12], #1   //read 1 byte of command data
        cmp    r11, #0
        beq    noInBandData
        cmp    r11, #76        //sanity check on size
        bgt    noInBandData
        mov    r11, r11, lsr #1
        ORR    r8, #BIT_SET_MODE2_16COLOUR          // mode 2 emulation enabled
        ORR    r8, #BIT_MODE2_PALETTE
commandloop:
        ldrb   r1, [r12], #1   //read 1 byte of command data
        and    r0, r1, #0x0f
        ldrb   r1, [r12], #1   //read 1 byte of command data
        and    r3, r1, #0xf0
        orr    r0, r0, r3, lsl #4
        and    r3, r1, #0x0f
        orr    r0, r0, r3, lsl #16
        orr    r0, r0, r0, lsl #4

        ldr    r2, [r10]
        str    r0, [r10], #4

        cmp    r0, r2
        movne  r9, #1

        subs   r11, r11, #1
        bne    commandloop

noInBandData:

        ldr    r10, =paletteFlags
        ldr    r7, [r10]
        str    r8, [r10]
        cmp    r9, #0
        cmpeq  r7, r8
        blne   osd_update_palette

        pop    {r1-r5,r11}


        // Update the OSD in Mode 0..6
        pop    {r11}
        tst    r3, #BIT_MODE7
        bne    skip_osd_update
        push   {r1-r5, r11}
        mov    r0, r11        // start of current draw buffer
        mov    r1, r2         // bytes per line
        bl     osd_update_fast
        pop    {r1-r5, r11}
        bic    r3, #BIT_FIELD_TYPE1_VALID   // *** temp workaround disables interlace change detection after osd update in case it takes longer than frame
skip_osd_update:


#ifdef MULTI_BUFFER
        // Update the last drawn buffer
        mov    r0, r3, lsr #OFFSET_CURR_BUFFER
        and    r0, #3
        bic    r3, r3, #MASK_LAST_BUFFER
        orr    r3, r3, r0, lsl #OFFSET_LAST_BUFFER
        // Flip to it on next V SYNC
        FLIP_BUFFER
#endif

        push   {r0-r12, lr}


        bl     recalculate_hdmi_clock_line_locked_update

        // Returns:
        //   r0=0 genlock disabled           - LED off
        //   r0=1 genlock enabled (unlocked) - LED flash
        //   r0=2 genlock enabled (locked)   - LED on

        READ_CYCLE_COUNTER r1

        mov    r2, #LED1_MASK
        tst    r0, #1         // should LED flash?
        tstne  r1, #(1 << 26) // flash rate ~ 8Hz
        tsteq  r0, #2         // should LED be on?
        ldrne  r1, =GPSET0    // LED on
        ldreq  r1, =GPCLR0    // LED off
        str    r2, [r1]

        pop    {r0-r12, lr}

        ldr    r0, lock_fail
        cmp    r0,#0
        bne    lock_failed

        // Loop back if required number of fields has not been reached
        // or if negative (capture forever)
        ldr    r5, param_ncapture
        cmp    r5, #0
        blt    frame
        subs   r5, #1
        str    r5, param_ncapture
        bne    frame

lock_failed:
        // Setup the response code
        mov    r0, r3
        and    r0, #BIT_MODE7
        orr    r0, #RET_EXPIRED

// Return
exit:
#ifdef MULTI_BUFFER
        // Save the old buffer state before exiting
        and    r3, r3, #MASK_LAST_BUFFER
        str    r3, buffer_state
        // Return the current buffer state
        orr    r0, r0, r3
#endif
        pop    {r4-r12, lr}
        mov    pc, lr

// ======================================================================
// ANALYSE SYNC POLARITY
// ======================================================================

analyse_sync:
        push    {r4-r12, lr}
        ldr    r4, =GPLEV0

        mov    r6, #0 //csync or hsync low
        mov    r7, #0 //csync or hsync high
        mov    r8, #0 //vsync low
        mov    r9, #0 //vsync high
        str    r9, sync_state
        READ_CYCLE_COUNTER r10
analyse_loop:        
        ldr    r5, [r4]
        tst    r5, #CSYNC_MASK
        addeq  r6, r6, #1
        addne  r7, r7, #1
        tst    r5, #VSYNC_MASK
        addeq  r8, r8, #1
        addne  r9, r9, #1
        READ_CYCLE_COUNTER r11
        subs   r12, r10, r11
        rsbmi  r12, r12, #0
        cmp    r12, #8388608<<3                       // 32ms = over a frame / field @ 50Hz
        blt    analyse_loop
        mov    r0, #SYNC_BIT_SEPARATE_SYNC
        cmp    r8, #0                              // is low count 0
        cmpne  r9, #0                              // if not is high count 0
        biceq  r0, r0, #SYNC_BIT_SEPARATE_SYNC    // if one or other is zero then no vsync pulses
        cmp    r6, r7                              // is low time > high time
        orrgt  r0, r0, #SYNC_BIT_HSYNC_INVERTED    // inverted means positive going
        cmp    r8, r9                              // is low time > high time
        orrgt  r0, r0, #SYNC_BIT_VSYNC_INVERTED    // inverted means positive going
        str    r0, sync_state
        
        pop    {r4-r12, pc}

        
// ======================================================================
// WAIT_FOR_VSYNC
// ======================================================================

wait_for_vsync:
        // Wait for end of vsync
        //
        // Returns:
        // r5 = duration of last csync low pulse
        // r6 = time of last rising edge of csync
        // r7 = time of last-but-one rising edge of csync

        // Working registers in the first half
        //
        // r4 = GPLEV0
        // r5 = time of falling edge
        // r6 = time of rising edge
        // r7 = time of previous rising edge
        // r8 = value read from GPLEV0
        // r9 = state variable (1 = seen a long pulse

        // Initialize "seen long pulse" to false (0)
        mov    r9, #0
        // Wait for csync to be high
        WAIT_FOR_CSYNC_1

vsync_loop:
        // Wait for the falling edge of csync
        WAIT_FOR_CSYNC_0

        // Record time of the falling edge

        READ_CYCLE_COUNTER r5

        // Wait for the rising edge of hsync
        WAIT_FOR_CSYNC_1

        // Save time of previous rising edge
        mov    r7, r6

        // Record time of the rising edge
        READ_CYCLE_COUNTER r6

        // Calculate length of low hsync pulse (in ARM cycles = ns)
        sub    r5, r6, r5

        // Compare with 8us to descriminate short from long
        // - normal hsync pulses are 4us
        // - during vsync everything is either inverted, or clamped to zero
        // - this results in hsync pulses between 9us and 128us

        ldr    r8, hsync_width
        cmp    r5, r8
        blt    seen_short

        // Set the state variable to indicate we are in the vsync
        mov    r9, #1

        // Loop back to wait for the next pulse
        b      vsync_loop

seen_short:
        // Test to see if we've seen any long pulses
        cmp    r9, #1
        // No, so look back for the next pulse
        bne    vsync_loop

        mov    pc, lr

// ======================================================================
// MEASURE_VSYNC
// ======================================================================

measure_vsync:
        push    {r4-r12, lr}
        
        mov    r3,#0
        ldr    r8, sync_state
        tst    r8, #SYNC_BIT_SEPARATE_SYNC 
        orrne  r3, r3, #BIT_SEPARATE_SYNC 
        tst    r8, #SYNC_BIT_VSYNC_INVERTED 
        orrne  r3, r3, #BIT_VSYNC_INVERTED
        
        // Setup R4 as a constant
        ldr    r4, =GPLEV0

        // wait for vsync, r6 contains the time of the subsequent hsync rising edge
        bl     wait_for_vsync
        mov    r0, r6

        // Wait for a first field of frame
        bl     wait_for_vsync

        // Record field type
        sub    r6, r6, r7
        cmp    r6, #FIELD_TYPE_THRESHOLD
        movlt  r12, #0         // Odd
        movge  r12, #1         // Even

        // Wait for a second field of frame
        bl     wait_for_vsync

        // Return the time for a complete frame (should be 40ms)
        sub    r0, r6, r0

        // Test for non-interlaced by looking for two successive fields of the same type
        sub    r6, r6, r7
        cmp    r6, #FIELD_TYPE_THRESHOLD
        eorlt  r12, r12, #1     // Odd
        tst    r12, #1
        // Set bit 31 of result if frame was interlaced
        orreq  r0, r0, #INTERLACED_FLAG

        pop    {r4-r12, pc}

// ======================================================================
// MEASURE_N_LINES
// ======================================================================

// Note: this is coded as a single loop with conditional mrc instructions
// to mitigate the effect of I-Cache misses.

measure_n_lines:
        push   {r4-r12, lr}
        mov    r3,#0
        ldr    r8, sync_state
        tst    r8, #SYNC_BIT_SEPARATE_SYNC 
        orrne  r3, r3, #BIT_SEPARATE_SYNC 
        tst    r8, #SYNC_BIT_VSYNC_INVERTED 
        orrne  r3, r3, #BIT_VSYNC_INVERTED
        // Setup R4 as a constant
        ldr    r4, =GPLEV0

        // wait for vsync
        bl     wait_for_vsync

        // skip 10 lines so we are well away from any double vsync pulses
        add    r1, r0, #10
        add    r0, r0, #1

        // r1 is the loop counter
measure_n_loop:
        WAIT_FOR_CSYNC_1
        WAIT_FOR_CSYNC_0
        cmp    r1, r0
        mrceq  p15, 0, r7, c15, c12, 1
        subs   r1, r1, #1
        mrceq  p15, 0, r6, c15, c12, 1
        bne    measure_n_loop

        sub    r0, r6, r7
        pop    {r4-r12, pc}

// ======================================================================
// CLEAR_SCREEN
// ======================================================================

clear_screen:
        ldr    r5, param_fb_height
        ldr    r6, param_fb_pitch
        ldr    r11, param_framebuffer0
        ldr    r8, =0x88888888
        mul    r6, r5, r6

#ifdef MULTI_BUFFER
        mov    r5, #NBUFFERS
        mul    r6, r5, r6
#endif

clear_loop:
        ldr    r7, [r11]
        subs   r6, r6, #4
        and    r7, r8
        str    r7, [r11], #4
        bne    clear_loop
        mov    pc, lr


// ======================================================================
// Local Variables
// ======================================================================

sw1counter:
        .word 0

sw2counter:
        .word 0

sw3counter:
        .word 0

param_framebuffer0:
        .word  0

#ifdef MULTI_BUFFER
param_framebuffer1:
        .word  0

param_framebuffer2:
        .word  0

param_framebuffer3:
        .word  0

buffer_state:
        .word  0
#endif

param_fb_pitch:
        .word  0

param_fb_width:
        .word  0

param_fb_height:
        .word  0

param_fb_heightx2:
        .word  0

param_fb_bpp:
        .word  0

param_chars_per_line:
        .word  0

param_nlines:
        .word  0

param_h_offset:
        .word  0

param_v_offset:
        .word  0

param_ncapture:
        .word  0

param_capture_line:
        .word 0

param_palette_control:
        .word 0

param_sample_width:
        .word 0

capture_address:
        .word 0

linecountmod10:
        .word 0

default_vsync_line:
        .word 0

sync_state:
        .word 0
        
vsync_line:
        .word 0

lock_fail:
        .word 0

hsync_width:
        .word 8000
        
offset_delay:
        .word 0
        
        .ltorg

customPalette:
        .space 1024, 0

paletteHighNibble:
        .space 1024, 0

dummyscreen:               // used by capture preload
        .space 8192, 0


capture_line_mode7_4bpp_table:
        .word capture_line_mode7_4bpp
        .word capture_line_mode7_4bpp
        .word capture_line_mode7_4bpp
        .word capture_line_mode7_4bpp
        .word capture_line_mode7_4bpp
        .word capture_line_mode7_4bpp

capture_line_normal_4bpp_table:
        .word capture_line_default_4bpp
        .word capture_line_sixbits_4bpp
        .word capture_line_inband_4bpp
        .word capture_line_sixbits_4bpp // placeholder for in band six bits
        .word capture_line_default_4bpp // placeholder for ntsc artifacting
        .word capture_line_sixbits_4bpp // placeholder for in band six bits

capture_line_odd_4bpp_table:
capture_line_even_4bpp_table:
        .word capture_line_oddeven_4bpp
        .word capture_line_sixbits_4bpp // placeholder for six bits
        .word capture_line_oddeven_4bpp // placeholder for in band
        .word capture_line_sixbits_4bpp // placeholder for in band six bits
        .word capture_line_oddeven_4bpp // placeholder for ntsc artifacting
        .word capture_line_sixbits_4bpp // placeholder for in band six bits

capture_line_double_4bpp_table:
        .word capture_line_double_4bpp
        .word capture_line_sixbits_4bpp // placeholder for six bits
        .word capture_line_double_4bpp  // placeholder for in band
        .word capture_line_sixbits_4bpp // placeholder for in band six bits
        .word capture_line_double_4bpp  // placeholder for ntsc artifacting
        .word capture_line_sixbits_4bpp // placeholder for in band six bits

capture_line_half_odd_4bpp_table:
capture_line_half_even_4bpp_table:
        .word capture_line_half_4bpp
        .word capture_line_sixbits_4bpp // placeholder for six bits
        .word capture_line_half_4bpp // placeholder for in band
        .word capture_line_sixbits_4bpp // placeholder for in band six bits
        .word capture_line_half_4bpp // placeholder for ntsc artifacting
        .word capture_line_sixbits_4bpp // placeholder for in band six bits


capture_line_normal_8bpp_table:
        .word capture_line_default_8bpp
        .word capture_line_sixbits_8bpp
        .word capture_line_inband_8bpp
        .word capture_line_sixbits_8bpp // placeholder for in band six bits
        .word capture_line_default_8bpp // placeholder for ntsc artifacting
        .word capture_line_sixbits_8bpp // placeholder for in band six bits

capture_line_odd_8bpp_table:
capture_line_even_8bpp_table:
        .word capture_line_oddeven_8bpp
        .word capture_line_sixbits_8bpp // placeholder for six bits
        .word capture_line_oddeven_8bpp // placeholder for in band
        .word capture_line_sixbits_8bpp // placeholder for in band six bits
        .word capture_line_oddeven_8bpp // placeholder for ntsc artifacting
        .word capture_line_sixbits_8bpp // placeholder for in band six bits

capture_line_double_8bpp_table:
        .word capture_line_double_8bpp
        .word capture_line_sixbits_8bpp // placeholder for six bits
        .word capture_line_double_8bpp  // placeholder for in band
        .word capture_line_sixbits_8bpp // placeholder for in band six bits
        .word capture_line_double_8bpp  // placeholder for ntsc artifacting
        .word capture_line_sixbits_8bpp // placeholder for in band six bits

capture_line_half_odd_8bpp_table:
capture_line_half_even_8bpp_table:
        .word capture_line_half_8bpp
        .word capture_line_sixbits_8bpp // placeholder for six bits
        .word capture_line_half_8bpp    // placeholder for in band
        .word capture_line_sixbits_8bpp // placeholder for in band six bits
        .word capture_line_half_8bpp    // placeholder for ntsc artifacting
        .word capture_line_sixbits_8bpp // placeholder for in band six bits

capture_line_atom_4bpp_table:
        .word capture_line_atom_4bpp;
        .word capture_line_atom_4bpp;
        .word capture_line_atom_4bpp;
        .word capture_line_atom_4bpp;
        .word capture_line_atom_4bpp;
        .word capture_line_atom_4bpp;

capture_line_atom_8bpp_table:
        .word capture_line_atom_8bpp;
        .word capture_line_atom_8bpp;
        .word capture_line_atom_8bpp;
        .word capture_line_atom_8bpp;
        .word capture_line_atom_8bpp;
        .word capture_line_atom_8bpp;
